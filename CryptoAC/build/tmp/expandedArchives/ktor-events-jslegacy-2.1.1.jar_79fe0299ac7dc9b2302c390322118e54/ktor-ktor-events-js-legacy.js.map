{"version":3,"file":"ktor-ktor-events-js-legacy.js","sources":["../../../../../ktor-shared/ktor-events/common/src/io/ktor/events/Events.kt","../../../../../js/src/internal/LinkedList.kt"],"sourcesContent":["/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.events\n\nimport io.ktor.util.*\nimport io.ktor.util.collections.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\n\n@OptIn(InternalAPI::class)\npublic class Events {\n    @OptIn(InternalCoroutinesApi::class)\n    private val handlers = CopyOnWriteHashMap<EventDefinition<*>, LockFreeLinkedListHead>()\n\n    /**\n     * Subscribe [handler] to an event specified by [definition]\n     */\n    public fun <T> subscribe(definition: EventDefinition<T>, handler: EventHandler<T>): DisposableHandle {\n        val registration = HandlerRegistration(handler)\n        @OptIn(InternalCoroutinesApi::class)\n        handlers.computeIfAbsent(definition) { LockFreeLinkedListHead() }.addLast(registration)\n        return registration\n    }\n\n    /**\n     * Unsubscribe [handler] from an event specified by [definition]\n     */\n    public fun <T> unsubscribe(definition: EventDefinition<T>, handler: EventHandler<T>) {\n        @OptIn(InternalCoroutinesApi::class)\n        handlers[definition]?.forEach<HandlerRegistration> {\n            if (it.handler == handler) it.remove()\n        }\n    }\n\n    /**\n     * Raises the event specified by [definition] with the [value] and calls all handlers.\n     *\n     * Handlers are called in order of subscriptions.\n     * If some handler throws an exception, all remaining handlers will still run. The exception will eventually be re-thrown.\n     */\n    public fun <T> raise(definition: EventDefinition<T>, value: T) {\n        var exception: Throwable? = null\n        handlers[definition]?.forEach<HandlerRegistration> { registration ->\n            try {\n                @Suppress(\"UNCHECKED_CAST\")\n                (registration.handler as EventHandler<T>)(value)\n            } catch (e: Throwable) {\n                exception?.addSuppressed(e) ?: run { exception = e }\n            }\n        }\n        exception?.let { throw it }\n    }\n\n    @OptIn(InternalCoroutinesApi::class)\n    private class HandlerRegistration(val handler: EventHandler<*>) : LockFreeLinkedListNode(), DisposableHandle {\n        override fun dispose() {\n            remove()\n        }\n    }\n}\n\n/**\n * Specifies signature for the event handler\n */\npublic typealias EventHandler<T> = (T) -> Unit\n\n// TODO: make two things: definition that is kept private to subsystem, and declaration which is public.\n// Invoke only by definition, subscribe by declaration\n\n/**\n * Definition of an event.\n * Event is used as a key so both [hashCode] and [equals] need to be implemented properly.\n * Inheriting of this class is an experimental feature.\n * Instantiate directly if inheritance not necessary.\n *\n * @param T specifies what is a type of a value passed to the event\n */\npublic open class EventDefinition<T>\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAWA,kB;IAEI,kBACuB,wB;G;EAQkB,qC;IAAE,2B;EAAyB,C;uCANpE,+B;IAII,mBAAmB,+BAAoB,OAApB,C;IAEnB,eAAS,yBAAgB,UAAhB,EAA4B,uBAA5B,CAAyD,iBAAQ,YAAR,C;IAClE,OAAO,Y;EACX,C;EAOuD,oD;IAAA,qB;MAC/C,IAAI,OAAA,EAAG,QAAH,EAAc,eAAd,CAAJ,C;QAA2B,EAAG,S;MAClC,W;IAAA,C;G;yCAPJ,+B;IAKI,Q;IAAA,wCAAS,UAAT,W;MC4IA,UAAgB,U;MAChB,OAAO,kBAAP,C;QACI,IAAI,8CAAJ,C;UD9I+C,kCC8IjC,CAAM,GAAN,C;QACd,MAAM,GAAI,M;;;ED5IlB,C;EAUuD,4E;IAAA,+B;UAG7B,I,EAEd,M;;QAFA,CAAC,QAAa,OAAb,YAAa,QAAb,oCAAD,EAA0C,aAA1C,C;;QACF,gC;UACE,qEAAyB,CAAzB,yB;YAAmC,iB;YAAE,sBAAY,S;;;UAJrD,O;;MAMJ,W;IAAA,C;G;mCAfJ,6B;IAQI,UAQA,M;IATA,oBAA4B,IAA5B,C;IACA,wCAAS,UAAT,W;MC+HA,UAAgB,U;MAChB,OAAO,kBAAP,C;QACI,IAAI,8CAAJ,C;UDjI+C,2CCiIjC,CAAM,GAAN,C;QACd,MAAM,GAAI,M;;;ID1Hd,mC;MAAiB,Y;;EACrB,C;EAGiC,6C;IAAiC,yB;IAAhC,sB;G;iDAC9B,Y;IACI,a;EACJ,C;;;;;;;;;;;EAYR,2B;G;;;;;;;;;;;;;;;"}