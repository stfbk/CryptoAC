# CryptoAC | Documentation | Metadata Manager

To properly function, *CryptoAC* needs to maintain metadata, e.g., on the status of the access control policy and cryptographic material (e.g., public keys). The Metadata Manager (MM) is the entity that manages such metadata and it usually is a database (e.g., MySQL, Redis). As for the DM, the MM can be operated by a partially-trusted agent.

In detail, the following implementations of the MM are available (between square parenthesis there is the list of scenarios compatible with the related implementation):
* [CLOUD, MQTT] **MMMySQL** - the MM is implemented with a MySQL8+ database. The database is initialized with a [**MySQL script**](./mysqldatabase.sql), while the tables, views and triggers are created by *CryptoAC* at run-time. To hide (potentially sensitive) identifiers and avoid the disclosure of the access control policy to the users, we limit users' *SELECT* privileges to grant access to tokens only and employ views and row-level permissions. Views automatically filter entries not associated with the user querying the database, whose username is available through the USER() MySQL function. This implies that the username with which the user connects to the database is the same the user has in the access control policy. In this way, each user knows his portion of the access control policy only and we respect the need-to-know principle (i.e., each user has access only to the information strictly needed to accomplish his task). To avoid stored-XSS attacks, all database inputs and outputs are sanitized: inputs are sanitized through the **PreparedStatement** Java class, while outputs are sanitized using the **OWASP Java Encoder**. All encrypted values are converted in Base64 before being stored in the database;
* [CLOUD, MQTT] **MMRedis** - the MM is implemented with a Redis in-memory data structure store. Redis is initialized with a [**configuration script**](./redis.conf). The metadata of each user (i.e., the public keys) are stored under a unique Redis key, while a list collects all users' Redis keys. We follow the same approach for the metadata of roles, topics, user-role assignments and role-topic permissions. Finally, access to the Redis datastore is protected by individual passwords.